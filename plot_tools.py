"""
Plot a factor in an upper triangular grid format.

To Do
-----
- It would be nice if the docstrings had the expected shapes of numpy arrays.
- Write a simple example in the __main__ block.
- Why is get_factor_features in this file? If it should be here, it would be
  helpful to write an example in the __main__ block too.
- The name of this file is plot_tools.py -- is the idea that more plotting
  functions will be added later? If not, the name is a bit vague.
"""
__date__ = "March 2021"

from IPython.core.debugger import set_trace
import numpy as np
from math import floor
import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
from re import findall



def factor_gridplot(diags, offdiags1, offdiags2, areaList=None, freqs=1, \
    labels=('',)):
    """
    Plots a factor in an upper triangular grid format

    Parameters
    ----------
    diags : numpy.ndarray
        Contains features that should be plotted in subfigures along the
        diagonal (e.g. PSD). Shape: [XXX]
    offdiags1 : numpy.ndarray
        Contains first set of features to be plotted in off-diagonal subfigures.
        Should have same scale as diag features. Shape: [XXX]
    offdiags2 : numpy.ndarray
        Contains second set of features to be plotted in off-diagonal
        subfigures. Can have different scaling than diag features.
    areaList : list of str?
        List of areas that features are generated from.
    freqs : list or int
        List of frequencies or scalar frequency sampling spacing (Hz). ...
    labels: tuple
        Tuple of 2 y-axis text labels. First label is applied to diags and
        offdiags1. Second label applies to offdiags2.
    """
    YLIM_SCALE = 1.15
    R_LABEL_SIZE = 12
    R_LABEL_X_OFF = -27
    R_LABEL_Y_OFF = 0.5

    A,F = diags.shape

    # calculate ylim values for plots
    max_val1 = np.max([np.max(abs(diags)), np.max(abs(offdiags1))])
    max_val2 = np.max(abs(offdiags2))
    ylims1 = YLIM_SCALE*np.asarray([0, 1])
    ylims2 = YLIM_SCALE*np.asarray([-max_val2/max_val1, max_val2/max_val1])

    # generate 'upper triangular' grid of subplots
    diag_ax = np.full(A, None, dtype=object)
    offd_ax1 = np.full((A,A), None, dtype=object)
    offd_ax2 = np.full((A,A), None, dtype=object)
    fig1 = plt.figure(constrained_layout=False)
    spec1 = gridspec.GridSpec(ncols=A, nrows=A, figure=fig1)
    for k in range(A):
        diag_ax[k] = fig1.add_subplot(spec1[k,k])
    for k in range(A):
        for l in range(k+1,A):
            offd_ax1[k,l] = fig1.add_subplot(spec1[k,l])
            offd_ax2[k,l] = offd_ax1[k,l].twinx()

    # convert frequencies to array if scalar frequency resolution given
    if np.isscalar(freqs):
        freqs = np.arange(1,F+1,freqs)

    # fill diagonal plots
    for k in range(A):
        diag_ax[k].plot(freqs, diags[k]/max_val1)
        diag_ax[k].set_ylim(ylims1)

    # fill off diagonal plots
    for k in range(A):
        for l in range(k+1,A):
            offd_ax1[k,l].plot(freqs, offdiags1[k,l]/max_val1, color='k')
            offd_ax2[k,l].plot(freqs, offdiags2[k,l]/max_val1, color='r')
            offd_ax1[k,l].set_ylim(ylims1)
            offd_ax2[k,l].set_ylim(ylims2)


    # handle legends, fonts, etc.. for diagonal plots
    for k in range(A):
        diag_ax[k].set_xlabel('Hz')
        diag_ax[k].set_ylabel(labels[0], color='k')
        freq_ticks = (freqs[0], int(freqs[-1]/2), freqs[-1])
        diag_ax[k].set_xticks(freq_ticks)
        if k == 0 and areaList is not None:
            diag_ax[0].set_title(areaList[0], fontsize=R_LABEL_SIZE, \
                    fontweight='bold')
        diag_ax[k].text(R_LABEL_X_OFF, R_LABEL_Y_OFF, areaList[k],
                        fontsize=R_LABEL_SIZE, fontweight='bold')

    # handle legends, fonts, etc.. for off diagonal plots
    for k in range(A):
        for l in range(k+1,A):
            offd_ax1[k,l].axes.yaxis.set_ticks([])
            offd_ax1[k,l].axes.xaxis.set_ticks([])
            offd_ax2[k,l].axes.xaxis.set_ticks([])
            if k == 0 and areaList is not None:
                offd_ax1[k,l].set_title(areaList[l], fontweight='bold')
            if l == (A-1):
                offd_ax2[k,l].set_ylabel(labels[1], color='r')
                offd_ax2[k,l].yaxis.set_label_position("right")
                offd_ax2[k,l].set_yticks((-1,0,1))
            else:
                offd_ax2[k,l].axes.yaxis.set_ticks([])


def get_factor_features(feature_str, feature_labels, factor):
    """
    Return the indicated subset of factor features.

    Parameters
    ----------
    feature_str : str
        string indicating type of features to extract
    feature_labels : list of str
        list of labels indicating the features represented in 'factor'. These
        are generated by 'saveFeatures.m' and contained in the labels loaded in
        by 'load_data'
    factor : ???
        components vector, or loadings, from a single factor of a linear factor
        model.

    Returns
    -------
    factor_features : type?
        The specified subset of the components vector.
    """
    f_list = [findall(feature_str, fl) for fl in feature_labels]
    f_idx = [bool(x) for x in f_list]
    return factor[f_idx]



if __name__ == '__main__':
    # Make an example plot with some fake data.
    np.random.seed(42)
    diags = np.random.rand()
    pass



###
